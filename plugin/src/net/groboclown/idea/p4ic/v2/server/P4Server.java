/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package net.groboclown.idea.p4ic.v2.server;

import com.intellij.openapi.project.Project;
import com.intellij.openapi.vcs.FilePath;
import com.intellij.openapi.vfs.VirtualFile;
import net.groboclown.idea.p4ic.config.ServerConfig;
import net.groboclown.idea.p4ic.server.ServerExecutor;
import net.groboclown.idea.p4ic.v2.server.cache.ClientServerId;
import net.groboclown.idea.p4ic.v2.server.cache.state.PendingUpdateState;
import net.groboclown.idea.p4ic.v2.server.cache.sync.ClientCacheManager;
import net.groboclown.idea.p4ic.v2.server.connection.AlertManager;
import net.groboclown.idea.p4ic.v2.server.connection.ProjectConfigSource;
import net.groboclown.idea.p4ic.v2.server.connection.ServerConnection;
import net.groboclown.idea.p4ic.v2.server.connection.ServerConnection.CacheQuery;
import net.groboclown.idea.p4ic.v2.server.connection.ServerConnection.CreateUpdate;
import net.groboclown.idea.p4ic.v2.server.connection.ServerConnectionManager;
import net.groboclown.idea.p4ic.v2.server.util.FilePathUtil;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

/**
 * Top-level manager for handling communication with the Perforce server
 * for a single client/server connection.
 * <p/>
 * The owner of this object needs to be aware of config changes; those
 * signal that the server instances are no longer valid.
 * It should listen to {@link net.groboclown.idea.p4ic.v2.events.BaseConfigUpdatedListener#TOPIC} events, which
 * are generated by {@link net.groboclown.idea.p4ic.config.P4ConfigProject}.
 * <p/>
 * The owner should also only save the state for valid server objects.
 * <p/>
 * This is a future replacement for {@link ServerExecutor}.  It connects
 * to a {@link ServerConnection}.
 */
public class P4Server {
    private final Project project;
    private final ServerConnection connection;
    private final AlertManager alertManager;
    private final ProjectConfigSource source;

    private boolean valid = true;


    P4Server(@NotNull final Project project, @NotNull final ProjectConfigSource source) {
        this.project = project;
        this.alertManager = AlertManager.getInstance();
        this.source = source;
        //this.clientState = AllClientsState.getInstance().getStateForClient(clientServerId);
        this.connection = ServerConnectionManager.getInstance().getConnectionFor(
                source.getClientServerId(), source.getServerConfig());
        connection.postSetup(project);
    }


    @NotNull
    public Project getProject() {
        return project;
    }


    public boolean isValid() {
        return valid;
    }

    public boolean isWorkingOnline() {
        return valid && connection.isWorkingOnline();
    }
    public boolean isWorkingOffline() {
        return ! valid || connection.isWorkingOffline();
    }

    /**
     * This does not perform link expansion (get absolute path).  We
     * assume that if you have a file under a path in a link, you want
     * it to be at that location, and not at its real location.
     *
     * @param file file to match against this client's root directories.
     * @return the directory depth at which this file is in the client.  This is the deepest depth for all
     *      the client roots.  It returns -1 if there is no match.
     */
    public int getFilePathMatchDepth(@NotNull FilePath file) {

        // FIXME return the *shallowest* depth, not the deepest depth.


        int deepest = -1;
        for (VirtualFile root: getClientRoots()) {
            final List<FilePath> inputParts = getPathParts(file);
            final List<FilePath> rootParts = getPathParts(FilePathUtil.getFilePath(root));

            if (inputParts.size() < rootParts.size()) {
                // input is at a higher ancestor level than the root parts,
                // so there's no way it could be in this root.
                continue;
            }

            // See if input is under the root.
            // We should be able to just call input.isUnder(configRoot), but
            // that seems to be buggy - it reported that "/a/b/c" was under "/a/b/d".

            final FilePath sameRootDepth = inputParts.get(rootParts.size() - 1);
            if (sameRootDepth.equals(root)) {
                // it's a match.  The input file ancestor path that is
                // at the same directory depth as the config root is the same
                // path.
                if (deepest < rootParts.size()) {
                    deepest = rootParts.size();
                }

                // Redundant - no code after this if block
                //continue;
            }

            // Not under the same path, so it's not a match.  Advance to next root.
        }
        return deepest;
    }

    public List<VirtualFile> getClientRoots() {
        return connection.cacheQuery(new CacheQuery<List<VirtualFile>>() {
            @Override
            public List<VirtualFile> query(@NotNull final ClientCacheManager mgr) {
                // FIXME use the ProjectConfigSource as the lowest level these can be under.
                return mgr.getClientRoots(project, alertManager);
            }
        });
    }


    /**
     * Return all files open for edit (or move, delete, etc) on this client.
     *
     * @return opened files state
     */
    public Collection<P4FileAction> getOpenFiles() {
        if (isWorkingOnline()) {
            // Fetch from the server and load up the caches.
        } else {

        }

        // FIXME
        throw new IllegalStateException("not implemented");
    }

    /**
     * Needs to be run immediately.
     *
     * @param files
     * @param changelistId
     */
    public void addOrEditFiles(@NotNull final List<VirtualFile> files, final int changelistId) {
        connection.queueUpdates(project, new CreateUpdate() {
            @Override
            public Collection<PendingUpdateState> create(@NotNull final ClientCacheManager mgr) {
                List<PendingUpdateState> updates = new ArrayList<PendingUpdateState>();
                for (VirtualFile file : files) {
                    final PendingUpdateState update = mgr.editFile(FilePathUtil.getFilePath(file), changelistId);
                    if (update != null) {
                        updates.add(update);
                    }
                }
                return updates;
            }
        });
    }


    /**
     * Set by the owning manager.
     *
     * @param isValid valid state
     */
    void setValid(boolean isValid) {
        valid = isValid;
    }


    public void dispose() {
        valid = false;
    }

    @NotNull
    public ClientServerId getClientServerId() {
        return source.getClientServerId();
    }

    @NotNull
    public ServerConfig getServerConfig() {
        return source.getServerConfig();
    }

    @Nullable
    public String getClientName() {
        return source.getClientName();
    }

    @NotNull
    private List<FilePath> getPathParts(@NotNull final FilePath child) {
        List<FilePath> ret = new ArrayList<FilePath>();
        FilePath next = child;
        while (next != null) {
            ret.add(next);
            next = next.getParentPath();
        }
        Collections.reverse(ret);
        return ret;
    }

    @Override
    public String toString() {
        return getClientServerId().toString();
    }
}

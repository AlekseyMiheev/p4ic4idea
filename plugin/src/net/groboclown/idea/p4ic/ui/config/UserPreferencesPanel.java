/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package net.groboclown.idea.p4ic.ui.config;

import com.intellij.uiDesigner.core.GridConstraints;
import com.intellij.uiDesigner.core.GridLayoutManager;
import com.intellij.uiDesigner.core.Spacer;
import net.groboclown.idea.p4ic.config.UserProjectPreferences;
import org.jetbrains.annotations.NotNull;

import javax.swing.*;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import java.awt.*;
import java.util.ArrayList;
import java.util.List;
import java.util.ResourceBundle;

public class UserPreferencesPanel {
    private JSpinner myMaxTimeout;
    private JPanel myRootPanel;
    private JCheckBox openForEditInCheckBox;


    public UserPreferencesPanel() {
        myMaxTimeout.setModel(new MinMaxSpinnerModel(
                UserProjectPreferences.MIN_CONNECTION_WAIT_TIME_MILLIS,
                UserProjectPreferences.MAX_CONNECTION_WAIT_TIME_MILLIS,
                500,
                UserProjectPreferences.DEFAULT_CONNECTION_WAIT_TIME_MILLIS));
    }


    protected void loadSettingsIntoGUI(@NotNull UserProjectPreferences userPrefs) {
        openForEditInCheckBox.setSelected(userPrefs.getEditInSeparateThread());
        myMaxTimeout.setValue(userPrefs.getMaxConnectionWaitTimeMillis());
    }


    protected void saveSettingsToConfig(@NotNull UserProjectPreferences userPrefs) {
        userPrefs.setDefaultEditInSeparateThread(getOpenForEditInSeparateThread());
        userPrefs.setMaxConnectionWaitTimeMillis(getMaxTimeout());
    }

    boolean isModified(@NotNull final UserProjectPreferences preferences) {
        return
                getOpenForEditInSeparateThread() != preferences.getEditInSeparateThread() ||
                        getMaxTimeout() != preferences.getMaxConnectionWaitTimeMillis();
    }


    boolean getOpenForEditInSeparateThread() {
        return openForEditInCheckBox.isSelected();
    }


    int getMaxTimeout() {
        return (Integer) myMaxTimeout.getModel().getValue();
    }

    {
// GUI initializer generated by IntelliJ IDEA GUI Designer
// >>> IMPORTANT!! <<<
// DO NOT EDIT OR ADD ANY CODE HERE!
        $$$setupUI$$$();
    }

    /**
     * Method generated by IntelliJ IDEA GUI Designer
     * >>> IMPORTANT!! <<<
     * DO NOT edit this method OR call it in your code!
     *
     * @noinspection ALL
     */
    private void $$$setupUI$$$() {
        myRootPanel = new JPanel();
        myRootPanel.setLayout(new GridLayoutManager(3, 2, new Insets(0, 0, 0, 0), -1, -1));
        final Spacer spacer1 = new Spacer();
        myRootPanel.add(spacer1,
                new GridConstraints(2, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_VERTICAL, 1,
                        GridConstraints.SIZEPOLICY_WANT_GROW, null, null, null, 0, false));
        final JLabel label1 = new JLabel();
        this.$$$loadLabelText$$$(label1,
                ResourceBundle.getBundle("net/groboclown/idea/p4ic/P4Bundle").getString("user.prefs.max_timeout"));
        myRootPanel.add(label1, new GridConstraints(1, 0, 1, 1, GridConstraints.ANCHOR_EAST, GridConstraints.FILL_NONE,
                GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        myMaxTimeout = new JSpinner();
        myRootPanel.add(myMaxTimeout,
                new GridConstraints(1, 1, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE,
                        GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0,
                        false));
        openForEditInCheckBox = new JCheckBox();
        this.$$$loadButtonText$$$(openForEditInCheckBox, ResourceBundle.getBundle("net/groboclown/idea/p4ic/P4Bundle")
                .getString("user.prefs.edit_in_separate_thread"));
        myRootPanel.add(openForEditInCheckBox,
                new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE,
                        GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,
                        GridConstraints.SIZEPOLICY_FIXED, null, null, null, 1, false));
        label1.setLabelFor(myMaxTimeout);
    }

    /**
     * @noinspection ALL
     */
    private void $$$loadLabelText$$$(JLabel component, String text) {
        StringBuffer result = new StringBuffer();
        boolean haveMnemonic = false;
        char mnemonic = '\0';
        int mnemonicIndex = -1;
        for (int i = 0; i < text.length(); i++) {
            if (text.charAt(i) == '&') {
                i++;
                if (i == text.length()) {
                    break;
                }
                if (!haveMnemonic && text.charAt(i) != '&') {
                    haveMnemonic = true;
                    mnemonic = text.charAt(i);
                    mnemonicIndex = result.length();
                }
            }
            result.append(text.charAt(i));
        }
        component.setText(result.toString());
        if (haveMnemonic) {
            component.setDisplayedMnemonic(mnemonic);
            component.setDisplayedMnemonicIndex(mnemonicIndex);
        }
    }

    /**
     * @noinspection ALL
     */
    private void $$$loadButtonText$$$(AbstractButton component, String text) {
        StringBuffer result = new StringBuffer();
        boolean haveMnemonic = false;
        char mnemonic = '\0';
        int mnemonicIndex = -1;
        for (int i = 0; i < text.length(); i++) {
            if (text.charAt(i) == '&') {
                i++;
                if (i == text.length()) {
                    break;
                }
                if (!haveMnemonic && text.charAt(i) != '&') {
                    haveMnemonic = true;
                    mnemonic = text.charAt(i);
                    mnemonicIndex = result.length();
                }
            }
            result.append(text.charAt(i));
        }
        component.setText(result.toString());
        if (haveMnemonic) {
            component.setMnemonic(mnemonic);
            component.setDisplayedMnemonicIndex(mnemonicIndex);
        }
    }

    /**
     * @noinspection ALL
     */
    public JComponent $$$getRootComponent$$$() {
        return myRootPanel;
    }


    static class MinMaxSpinnerModel implements SpinnerModel {
        private final List<ChangeListener> listeners = new ArrayList<ChangeListener>();
        private final int minValue;
        private final int maxValue;
        private final int step;
        private int value;

        MinMaxSpinnerModel(final int minValue, final int maxValue, final int step, final int initialValue) {
            this.minValue = minValue;
            this.maxValue = maxValue;
            this.step = step;
            this.value = initialValue;
        }

        @Override
        public Object getValue() {
            return value;
        }

        @Override
        public void setValue(final Object value) {
            if (value == null || !(value instanceof Number)) {
                return;
            }
            int newValue = Math.min(
                    maxValue,
                    Math.max(
                            minValue,
                            ((Number) value).intValue()));
            if (newValue != this.value) {
                this.value = newValue;
                synchronized (listeners) {
                    for (ChangeListener listener : listeners) {
                        listener.stateChanged(new ChangeEvent(this));
                    }
                }
            }
        }

        @Override
        public Object getNextValue() {
            return Math.min(maxValue, value + step);
        }

        @Override
        public Object getPreviousValue() {
            return Math.max(minValue, value - step);
        }

        @Override
        public void addChangeListener(final ChangeListener l) {
            if (l != null) {
                synchronized (listeners) {
                    listeners.add(l);
                }
            }
        }

        @Override
        public void removeChangeListener(final ChangeListener l) {
            synchronized (listeners) {
                listeners.remove(l);
            }
        }
    }
}
